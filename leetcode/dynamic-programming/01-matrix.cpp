#include <iostream>
#include <vector>
#include <queue>

class Solution
{
public:
	typedef std::pair<int, int> pair;
	inline std::vector<std::vector<int>> &updateMatrix(std::vector<std::vector<int>> &mat)
	{
		const auto M = mat.size();
		const auto N = mat[0].size();

		int i = 0;
		int j = 0;
		int k = 0;

		// method 1:
		// runtime: 1036ms this one works but pretty slow!

		// std::vector<std::vector<int>> res(M, std::vector<int>(N));
		// for (i = 0; i < M; i++)
		// {
		// 	for (j = 0; j < N; j++)
		// 	{
		// 		res[i][j] = -1;
		// 		if (mat[i][j] == 0)
		// 		{
		// 			q.push({i, j});
		// 			res[i][j] = 0;
		// 		}
		// 	}
		// }

		// const auto max = M + N;

		// while (k <= max)
		// {

		// 	bool exist = false;
		// 	for (i = 0; i < M; i++)
		// 	{
		// 		for (j = 0; j < N; j++)
		// 		{
		// 			if (res[i][j] == k)
		// 			{
		// 				exist = true;
		// 				// update the sroundings
		// 				if ((i - 1) >= 0 && res[i - 1][j] == -1)
		// 					res[i - 1][j] = k + 1;
		// 				if ((i + 1) < M && res[i + 1][j] == -1)
		// 					res[i + 1][j] = k + 1;
		// 				if ((j - 1) >= 0 && res[i][j - 1] == -1)
		// 					res[i][j - 1] = k + 1;
		// 				if ((j + 1) < N && res[i][j + 1] == -1)
		// 					res[i][j + 1] = k + 1;
		// 			}
		// 		}
		// 	}

		// 	if (!exist)
		// 		break;
		// 	k++;
		// }

		// return res;

		// method 2: using queue to remove the need to traverse each time in while loop
		// runtime: 84ms faster than almost 90% of the submissions

		const auto MAX = -1e3;
		std::queue<pair> q;
		for (i = 0; i < M; i++)
		{
			for (j = 0; j < N; j++)
			{
				if (mat[i][j] == 0)
				{
					q.push({i, j});
				}
				else
					mat[i][j] = MAX;
			}
		}

		while (!q.empty())
		{

			const auto [i, j] = q.front();
			q.pop();
			const auto k = mat[i][j];

			// update the sroundings
			if ((i - 1) >= 0 && mat[i - 1][j] == MAX)
			{
				mat[i - 1][j] = k + 1;
				q.push({i - 1, j});
			}

			if ((i + 1) < M && mat[i + 1][j] == MAX)
			{
				mat[i + 1][j] = k + 1;
				q.push({i + 1, j});
			}

			if ((j - 1) >= 0 && mat[i][j - 1] == MAX)
			{
				q.push({i, j - 1});
				mat[i][j - 1] = k + 1;
			}

			if ((j + 1) < N && mat[i][j + 1] == MAX)
			{
				q.push({i, j + 1});
				mat[i][j + 1] = k + 1;
			}
		}

		return mat;
	}
};

int main()
{
	std::vector<std::vector<int>> mat = {{1, 1, 1, 0, 0},
																			 {1, 1, 1, 1, 0},
																			 {1, 1, 1, 1, 0}};

	std::vector<std::vector<int>> mat2 = {{1, 1, 1, 1, 1, 0, 1, 0, 1, 0, 1, 0, 1, 1, 0, 1, 1, 1, 0, 1, 1, 1, 0, 1, 1, 1, 1, 0, 1, 1}, {1, 1, 1, 0, 1, 1, 0, 0, 0, 0, 1, 1, 1, 1, 1, 1, 1, 1, 1, 0, 1, 1, 1, 1, 1, 0, 1, 0, 0, 1}, {1, 1, 1, 1, 0, 1, 0, 0, 1, 1, 0, 1, 1, 0, 1, 1, 1, 0, 1, 0, 1, 0, 0, 1, 0, 1, 0, 1, 1, 1}, {1, 1, 1, 1, 1, 0, 1, 1, 1, 1, 1, 0, 1, 1, 0, 0, 0, 0, 1, 0, 0, 0, 0, 1, 1, 1, 1, 0, 0, 1}, {0, 1, 0, 0, 1, 0, 0, 1, 1, 1, 0, 1, 1, 1, 1, 1, 0, 1, 0, 1, 1, 1, 1, 1, 0, 1, 1, 1, 0, 1}, {1, 0, 1, 1, 1, 1, 0, 1, 0, 1, 0, 1, 1, 1, 0, 1, 1, 1, 1, 0, 1, 1, 0, 1, 0, 1, 0, 0, 1, 0}, {1, 1, 0, 1, 1, 0, 0, 0, 1, 1, 0, 0, 0, 1, 0, 1, 1, 1, 1, 1, 0, 1, 0, 1, 1, 0, 1, 1, 1, 1}, {1, 1, 1, 0, 0, 0, 1, 0, 0, 1, 1, 1, 1, 1, 1, 1, 1, 0, 1, 0, 1, 0, 0, 1, 0, 0, 1, 0, 0, 1}, {0, 1, 1, 0, 1, 1, 1, 0, 1, 0, 1, 1, 0, 1, 1, 1, 1, 0, 1, 0, 1, 1, 1, 1, 1, 0, 0, 1, 0, 1}, {1, 1, 0, 0, 1, 1, 1, 0, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 0, 0, 1, 1, 1, 1, 0, 0, 0, 0, 1, 1}, {1, 1, 1, 1, 1, 1, 1, 1, 0, 1, 1, 1, 1, 1, 1, 1, 0, 1, 1, 1, 0, 1, 1, 0, 1, 0, 1, 1, 1, 0}, {1, 1, 1, 1, 0, 1, 0, 0, 0, 1, 1, 1, 0, 1, 1, 1, 0, 1, 0, 1, 1, 1, 0, 1, 0, 1, 1, 1, 1, 1}, {0, 1, 1, 0, 0, 0, 0, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 0, 1, 0, 1, 1, 1, 1, 0, 1, 0, 0, 0, 1}, {0, 1, 1, 0, 0, 0, 1, 1, 0, 0, 0, 0, 1, 1, 0, 1, 1, 1, 1, 1, 1, 1, 0, 1, 0, 0, 1, 1, 1, 1}, {1, 1, 1, 1, 0, 0, 1, 1, 1, 0, 0, 1, 1, 0, 1, 1, 1, 0, 0, 1, 1, 0, 1, 0, 0, 0, 0, 1, 1, 1}, {1, 1, 1, 1, 0, 1, 1, 0, 1, 1, 0, 1, 1, 1, 1, 1, 1, 1, 0, 0, 0, 0, 1, 1, 0, 0, 1, 0, 0, 0}, {1, 1, 0, 1, 1, 0, 0, 1, 1, 0, 0, 1, 0, 1, 1, 1, 1, 0, 1, 1, 1, 0, 1, 1, 0, 1, 0, 1, 0, 1}, {1, 0, 0, 0, 1, 1, 1, 0, 1, 1, 1, 1, 0, 0, 1, 1, 1, 0, 1, 1, 0, 1, 0, 0, 1, 1, 1, 1, 1, 0}, {1, 1, 0, 1, 0, 1, 1, 0, 0, 1, 1, 0, 0, 1, 0, 1, 1, 1, 1, 1, 1, 0, 1, 0, 0, 0, 0, 1, 1, 1}, {1, 1, 1, 0, 1, 0, 1, 0, 1, 0, 1, 0, 1, 1, 0, 1, 0, 0, 1, 1, 1, 0, 1, 1, 0, 1, 0, 1, 1, 0}, {1, 0, 0, 1, 1, 1, 1, 0, 1, 0, 1, 1, 1, 0, 1, 1, 1, 0, 1, 1, 1, 0, 1, 1, 1, 1, 1, 0, 1, 1}, {0, 1, 1, 1, 1, 0, 1, 1, 0, 1, 1, 1, 1, 1, 1, 0, 1, 0, 0, 1, 0, 1, 1, 0, 1, 1, 0, 1, 0, 1}, {1, 1, 1, 0, 1, 1, 1, 0, 0, 1, 0, 0, 0, 1, 1, 1, 1, 0, 1, 1, 1, 0, 1, 1, 1, 1, 1, 1, 1, 1}, {1, 1, 0, 0, 1, 1, 1, 1, 0, 0, 1, 0, 0, 1, 1, 0, 0, 1, 1, 1, 1, 0, 1, 1, 0, 1, 1, 1, 1, 1}, {0, 0, 0, 1, 1, 1, 1, 1, 1, 0, 1, 1, 1, 0, 0, 1, 1, 1, 1, 1, 1, 1, 0, 1, 0, 0, 0, 1, 1, 0}, {1, 1, 0, 1, 1, 1, 1, 1, 1, 1, 1, 0, 1, 1, 0, 0, 1, 1, 1, 1, 0, 1, 0, 0, 0, 0, 0, 1, 1, 1}, {1, 0, 1, 1, 0, 1, 1, 0, 1, 0, 1, 1, 1, 0, 1, 1, 1, 1, 1, 0, 1, 0, 0, 1, 1, 0, 0, 1, 1, 0}, {1, 1, 1, 0, 0, 1, 1, 1, 1, 0, 1, 0, 1, 1, 1, 1, 1, 1, 1, 0, 0, 1, 1, 1, 1, 1, 1, 1, 1, 1}, {1, 1, 1, 1, 1, 0, 0, 1, 1, 1, 1, 1, 1, 1, 1, 0, 1, 1, 0, 1, 1, 1, 1, 1, 1, 0, 0, 1, 1, 1}, {0, 1, 1, 0, 1, 1, 0, 0, 1, 0, 1, 1, 1, 1, 0, 0, 1, 1, 1, 1, 1, 1, 0, 0, 0, 1, 1, 0, 1, 0}};

	Solution s;

	std::cout << "MAT 2: \n";
	for (const auto xs : mat)
	{
		for (const auto x : xs)
		{
			std::cout << x << ", ";
		}
		std::cout << "\n";
	}

	const auto res = s.updateMatrix(mat);
	std::cout << std::endl;
	std::cout << "Result: \n";

	for (const auto xs : res)
	{
		for (const auto x : xs)
		{
			std::cout << x << ", ";
		}
		std::cout << "\n";
	}
	return 0;
}